// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/lib/types/supabase-types';
import { toast } from 'sonner';

const SUPABASE_URL = "https://kgtfpuvksmqyaraijoal.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtndGZwdXZrc21xeWFyYWlqb2FsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM4MjAxMjksImV4cCI6MjA1OTM5NjEyOX0._fj5EqjZBmS_fHB5Z2p2lDJdXilePMUrbf3If_wGBz0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

console.log(`üîå Initializing Supabase client with URL: ${SUPABASE_URL}`);

// Create client with automatic retry and enhanced error handling
const options = {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true
  },
  global: {
    headers: {
      'x-application-name': 'ontario-loans',
      'x-client-info': 'application-form'
    }
  },
  realtime: {
    params: {
      eventsPerSecond: 1
    }
  }
};

// Fix: Remove the db.schema property from options since it's causing type errors
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, options);

// Log supabase version info
console.log(`üìä Supabase client initialized`);

// Enhanced logging for Supabase operations
const originalFrom = supabase.from.bind(supabase);
supabase.from = function(table: string) {
  if (!table || table === "") {
    console.error("‚ùå Supabase: Invalid table name provided (empty string)");
    return originalFrom("applications");
  }
  console.log(`üîç Supabase: Accessing table "${table}" at ${SUPABASE_URL}/rest/v1/${table}`);
  return originalFrom(table);
} as typeof supabase.from;

// Add a generic RPC function with proper type casting and async handling
export const rpcCall = async <T = any>(
  functionName: string,
  params?: Record<string, any>
): Promise<{ data: T | null; error: any }> => {
  console.log(`üü¢ Calling Supabase RPC function: ${functionName}`, params ? params : 'without params');
  console.log(`üåê RPC Endpoint: ${SUPABASE_URL}/rest/v1/rpc/${functionName}`);
  
  try {
    if (import.meta.env.DEV) {
      console.log(`üåê Supabase RPC URL: ${SUPABASE_URL}/rest/v1/rpc/${functionName}`);
    }
    
    const response = await supabase.rpc(functionName as any, params);
    
    if (response.error) {
      console.error(`‚ùå Supabase RPC error in ${functionName}:`, response.error);
      
      console.error(`‚ùå Message: ${response.error.message}`);
      
      if (response.error.details) {
        console.error(`‚ùå Error details:`, response.error.details);
      }
      
      if (response.error.hint) {
        console.error(`‚ùå Error hint:`, response.error.hint);
      }
      
      if (response.error.code) {
        console.error(`‚ùå Error code:`, response.error.code);
      }
    } else {
      console.log(`‚úÖ Supabase RPC success for ${functionName}:`, response.data ? 'Data received' : 'No data');
      if (import.meta.env.DEV) {
        console.log(`üì¶ Response data:`, response.data);
      }
    }
    
    return {
      data: response.data as T | null,
      error: response.error
    };
  } catch (err) {
    console.error(`‚ùå‚ùå Unexpected error in Supabase RPC call to ${functionName}:`, err);
    return {
      data: null,
      error: err
    };
  }
};

// Improved test Supabase connection function with better error handling and retries
export const testSupabaseConnection = async (retries = 2): Promise<{connected: boolean, latency?: number, error?: string, data?: any}> => {
  let startTime = 0;
  
  try {
    console.log('üîç Testing Supabase connection...');
    startTime = Date.now();
    
    // IMPORTANT FIX: Reduce timeout from 5000ms to 3000ms to prevent long hanging requests
    const timeoutPromise = new Promise<{data: null, error: any}>((_, reject) => {
      setTimeout(() => {
        reject({ error: { message: "Connection timeout after 3 seconds" } });
      }, 3000);
    });
    
    // Race between the actual query and the timeout
    const result = await Promise.race([
      supabase.from('applications').select('count').limit(1),
      timeoutPromise
    ]);
    
    const elapsed = Date.now() - startTime;
    
    if ('error' in result && result.error) {
      console.error(`‚ùå Supabase connection test failed after ${elapsed}ms:`, result.error);
      
      if (retries > 0) {
        console.log(`Retrying connection test (${retries} attempts left)...`);
        await new Promise(resolve => setTimeout(resolve, 500)); // Reduced from 1000ms to 500ms
        return testSupabaseConnection(retries - 1);
      }
      
      return {
        connected: false,
        latency: elapsed,
        error: result.error.message || "Unknown error"
      };
    }
    
    console.log(`‚úÖ Supabase connection successful (${elapsed}ms)`);
    return {
      connected: true,
      latency: elapsed,
      data: result.data
    };
  } catch (err: any) {
    const elapsed = Date.now() - startTime || 0;
    console.error(`‚ùå Unexpected Supabase connection error after ${elapsed}ms:`, err);
    
    if (retries > 0) {
      console.log(`Retrying connection test (${retries} attempts left)...`);
      await new Promise(resolve => setTimeout(resolve, 500)); // Reduced from 1000ms to 500ms
      return testSupabaseConnection(retries - 1);
    }
    
    return {
      connected: false,
      latency: elapsed,
      error: err instanceof Error ? err.message : String(err)
    };
  }
};

// Add connection heartbeat at regular intervals to keep connection alive
let connectionIsActive = false;

const startConnectionHeartbeat = () => {
  if (connectionIsActive) return;
  
  connectionIsActive = true;
  console.log('üîÑ Starting Supabase connection heartbeat');
  
  const heartbeatInterval = setInterval(() => {
    testSupabaseConnection(1)
      .then(status => {
        if (!status.connected) {
          console.warn('üíî Supabase connection heartbeat failed');
        }
      })
      .catch(err => {
        console.error('üíî Supabase connection heartbeat error:', err);
      });
  }, 60000); // Increased from 30000ms to 60000ms (1 minute) to reduce network load
  
  window.addEventListener('beforeunload', () => {
    clearInterval(heartbeatInterval);
  });
};

// Only start heartbeat in production to avoid excessive requests during development
if (import.meta.env.PROD) {
  // Add a small delay before starting the heartbeat
  setTimeout(() => startConnectionHeartbeat(), 5000);
}

// Enhance supabase insert and update operations with better logging
const enhanceSupabaseInsert = () => {
  const originalFrom = supabase.from.bind(supabase);
  
  supabase.from = function(table: string) {
    if (!table || table === "") {
      console.error("‚ùå Supabase: Invalid table name provided (empty string)");
      return originalFrom("applications");
    }
    
    const builder = originalFrom(table);
    const originalInsertFn = builder.insert;
    
    builder.insert = function(...args) {
      console.log(`üìù Supabase: INSERT into "${table}" with data:`, args[0]);
      console.log(`üåê INSERT endpoint: ${SUPABASE_URL}/rest/v1/${table}`);
      
      const insertResult = originalInsertFn.apply(this, args);
      
      const originalThen = insertResult.then;
      insertResult.then = function(onFulfilled, onRejected) {
        return originalThen.call(this, (result) => {
          if (result.error) {
            console.error(`‚ùå Supabase: INSERT failed for "${table}":`, result.error);
            console.error(`‚ùå Error message: ${result.error.message}`);
            if (result.error.details) {
              console.error(`‚ùå Error details:`, result.error.details);
            }
            if (result.error.code) {
              console.error(`‚ùå Error code:`, result.error.code);
            }
          } else {
            console.log(`‚úÖ Supabase: INSERT successful for "${table}"`, result.data);
          }
          return onFulfilled ? onFulfilled(result) : result;
        }, onRejected);
      };
      
      return insertResult;
    };
    
    return builder;
  } as typeof supabase.from;
};

// Initialize the enhanced methods
enhanceSupabaseInsert();

// Add debugging info to Application page to show endpoint and connection status
export const getSupabaseConnectionInfo = () => {
  return {
    url: SUPABASE_URL,
    tables: {
      applications: `${SUPABASE_URL}/rest/v1/applications`
    },
    isConnected: true
  };
};

// Check and report connection status on page load
window.addEventListener('DOMContentLoaded', () => {
  // Initialize connection check on page load with a small delay
  setTimeout(() => {
    testSupabaseConnection()
      .then(status => {
        if (!status.connected) {
          console.warn('‚ö†Ô∏è Initial connection check failed. Some features may not work properly.');
          toast.warning("Database connection issues detected. Some features may not work properly.");
        }
      })
      .catch(err => {
        console.error('‚ö†Ô∏è Error during initial connection check:', err);
      });
  }, 2000); // Increased delay to allow page to load first
});

// Expose function to check for network connectivity issues
export const checkNetworkConnectivity = async (): Promise<boolean> => {
  try {
    // First try to fetch a small resource as a general internet connectivity test
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
    
    const response = await fetch('https://www.google.com/favicon.ico', { 
      mode: 'no-cors',
      cache: 'no-cache',
      method: 'HEAD',
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    return true;
  } catch (err) {
    console.error('Network connectivity check failed:', err);
    return false;
  }
};

// Function to diagnose connection issues
export const diagnoseConnectionIssues = async (): Promise<string> => {
  const hasNetwork = await checkNetworkConnectivity();
  
  if (!hasNetwork) {
    return "No network connectivity detected. Please check your internet connection.";
  }
  
  return "Network connection appears to be working, but database connection failed. This may be a temporary issue.";
};
