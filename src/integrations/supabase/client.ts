
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/lib/types/supabase-types';
import { toast } from 'sonner';

const SUPABASE_URL = "https://kgtfpuvksmqyaraijoal.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtndGZwdXZrc21xeWFyYWlqb2FsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM4MjAxMjksImV4cCI6MjA1OTM5NjEyOX0._fj5EqjZBmS_fHB5Z2p2lDJdXilePMUrbf3If_wGBz0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

console.log(`üîå Initializing Supabase client with URL: ${SUPABASE_URL}`);

// Create client with automatic retry and enhanced error handling
const options = {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    storageKey: 'supabase.auth.token',
    storage: window.localStorage
  },
  global: {
    headers: {
      // Removed x-application-name header that was causing CORS issues
    }
  },
  realtime: {
    params: {
      eventsPerSecond: 1
    }
  },
  persistSession: true,  // Legacy prop for backward compatibility
};

// Create the Supabase client 
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, options);

// Log supabase version info
console.log(`üìä Supabase client initialized`);

// Enhanced logging for Supabase operations
const originalFrom = supabase.from.bind(supabase);
supabase.from = function(table: string) {
  if (!table || table === "") {
    console.error("‚ùå Supabase: Invalid table name provided (empty string)");
    return originalFrom("applications");
  }
  console.log(`üîç Supabase: Accessing table "${table}" at ${SUPABASE_URL}/rest/v1/${table}`);
  return originalFrom(table);
} as typeof supabase.from;

// Add a generic RPC function with proper type casting and async handling
export const rpcCall = async <T = any>(
  functionName: string,
  params?: Record<string, any>
): Promise<{ data: T | null; error: any }> => {
  console.log(`üü¢ Calling Supabase RPC function: ${functionName}`, params ? params : 'without params');
  console.log(`üåê RPC Endpoint: ${SUPABASE_URL}/rest/v1/rpc/${functionName}`);
  
  try {
    if (import.meta.env.DEV) {
      console.log(`üåê Supabase RPC URL: ${SUPABASE_URL}/rest/v1/rpc/${functionName}`);
    }
    
    const response = await supabase.rpc(functionName as any, params);
    
    if (response.error) {
      console.error(`‚ùå Supabase RPC error in ${functionName}:`, response.error);
      
      console.error(`‚ùå Message: ${response.error.message}`);
      
      if (response.error.details) {
        console.error(`‚ùå Error details:`, response.error.details);
      }
      
      if (response.error.hint) {
        console.error(`‚ùå Error hint:`, response.error.hint);
      }
      
      if (response.error.code) {
        console.error(`‚ùå Error code:`, response.error.code);
      }
    } else {
      console.log(`‚úÖ Supabase RPC success for ${functionName}:`, response.data ? 'Data received' : 'No data');
      if (import.meta.env.DEV) {
        console.log(`üì¶ Response data:`, response.data);
      }
    }
    
    return {
      data: response.data as T | null,
      error: response.error
    };
  } catch (err) {
    console.error(`‚ùå‚ùå Unexpected error in Supabase RPC call to ${functionName}:`, err);
    return {
      data: null,
      error: err
    };
  }
};

// Improved test Supabase connection function with better error handling and retries
export const testSupabaseConnection = async (retries = 2): Promise<{connected: boolean, latency?: number, error?: string, data?: any}> => {
  let startTime = 0;
  
  try {
    console.log('üîç Testing Supabase connection...');
    startTime = Date.now();
    
    // Try with a simple query first that doesn't require multiple rows
    const timeoutPromise = new Promise<{data: null, error: any}>((_, reject) => {
      setTimeout(() => {
        reject({ error: { message: "Connection timeout after 3 seconds" } });
      }, 3000);
    });
    
    // Race between the actual query and the timeout
    const result = await Promise.race([
      supabase.from('applications').select('count').limit(1).single(),
      timeoutPromise
    ]);
    
    const elapsed = Date.now() - startTime;
    
    if ('error' in result && result.error) {
      // If it's a "no rows returned" error, that's still a successful connection
      if (result.error.code === 'PGRST116') {
        console.log(`‚úÖ Supabase connection successful (${elapsed}ms) - no data found but connection works`);
        return {
          connected: true,
          latency: elapsed
        };
      }
      
      console.error(`‚ùå Supabase connection test failed after ${elapsed}ms:`, result.error);
      
      if (retries > 0) {
        console.log(`Retrying connection test (${retries} attempts left)...`);
        await new Promise(resolve => setTimeout(resolve, 500));
        return testSupabaseConnection(retries - 1);
      }
      
      return {
        connected: false,
        latency: elapsed,
        error: result.error.message || "Unknown error"
      };
    }
    
    console.log(`‚úÖ Supabase connection successful (${elapsed}ms)`);
    return {
      connected: true,
      latency: elapsed,
      data: result.data
    };
  } catch (err: any) {
    const elapsed = Date.now() - startTime || 0;
    console.error(`‚ùå Unexpected Supabase connection error after ${elapsed}ms:`, err);
    
    if (retries > 0) {
      console.log(`Retrying connection test (${retries} attempts left)...`);
      await new Promise(resolve => setTimeout(resolve, 500));
      return testSupabaseConnection(retries - 1);
    }
    
    return {
      connected: false,
      latency: elapsed,
      error: err instanceof Error ? err.message : String(err)
    };
  }
};

// Add connection heartbeat at regular intervals to keep connection alive
let connectionIsActive = false;

const startConnectionHeartbeat = () => {
  if (connectionIsActive) return;
  
  connectionIsActive = true;
  console.log('üîÑ Starting Supabase connection heartbeat');
  
  // Using fetch instead of supabase client for more reliability
  const heartbeatInterval = setInterval(() => {
    fetch(`${SUPABASE_URL}/rest/v1/applications?count=exact&limit=1`, {
      method: 'HEAD',
      headers: {
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
      }
    }).catch(err => {
      console.warn('üíî Supabase heartbeat error:', err);
    });
  }, 30000); // Every 30 seconds
  
  window.addEventListener('beforeunload', () => {
    clearInterval(heartbeatInterval);
  });
};

// Start heartbeat with a small delay after page load
setTimeout(() => startConnectionHeartbeat(), 5000);

// Function to diagnose connection issues
export const diagnoseConnectionIssues = async (): Promise<string> => {
  try {
    // First check general internet connectivity
    const hasNetwork = await checkNetworkConnectivity();
    
    if (!hasNetwork) {
      return "No network connectivity detected. Please check your internet connection.";
    }
    
    // Try a direct connection to Supabase API
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 2000);
      
      const response = await fetch(`${SUPABASE_URL}/rest/v1/`, { 
        method: 'HEAD',
        headers: {
          'apikey': SUPABASE_PUBLISHABLE_KEY,
        },
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (response.ok || response.status === 400) {
        return "Supabase API is reachable but authentication may have issues. Try refreshing the page or signing in again.";
      } else {
        return `Supabase API returned status ${response.status}. Service may be experiencing issues.`;
      }
    } catch (err: any) {
      if (err.name === 'AbortError') {
        return "Connection to Supabase timed out. The service might be experiencing high load or network issues.";
      }
      return "Could not connect to Supabase API. Please try again later.";
    }
  } catch (err) {
    console.error('Error during connection diagnosis:', err);
    return "An error occurred while diagnosing the connection. Please check your internet connection and try again.";
  }
};

// Expose function to check for network connectivity issues
export const checkNetworkConnectivity = async (): Promise<boolean> => {
  try {
    // First try to fetch a small resource as a general internet connectivity test
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
    
    const response = await fetch('https://www.google.com/favicon.ico', { 
      mode: 'no-cors',
      cache: 'no-cache',
      method: 'HEAD',
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    return true;
  } catch (err) {
    console.error('Network connectivity check failed:', err);
    return false;
  }
};

// Check and report connection status on page load
window.addEventListener('DOMContentLoaded', () => {
  // Initialize connection check on page load with a small delay
  setTimeout(() => {
    testSupabaseConnection()
      .then(status => {
        if (!status.connected) {
          console.warn('‚ö†Ô∏è Initial connection check failed. Some features may not work properly.');
          toast.warning("Database connection issues detected. Some features may not work properly.");
        }
      })
      .catch(err => {
        console.error('‚ö†Ô∏è Error during initial connection check:', err);
      });
  }, 2000);
});

// Get connection info for debugging
export const getSupabaseConnectionInfo = () => {
  return {
    url: SUPABASE_URL,
    tables: {
      applications: `${SUPABASE_URL}/rest/v1/applications`
    },
    isConnected: true
  };
};
