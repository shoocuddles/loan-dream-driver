
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://kgtfpuvksmqyaraijoal.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtndGZwdXZrc21xeWFyYWlqb2FsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM4MjAxMjksImV4cCI6MjA1OTM5NjEyOX0._fj5EqjZBmS_fHB5Z2p2lDJdXilePMUrbf3If_wGBz0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

console.log(`üîå Initializing Supabase client with URL: ${SUPABASE_URL}`);
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true
  },
  global: {
    headers: {
      'x-application-name': 'ontario-loans'
    }
  }
});

// Log supabase version info
console.log(`üìä Supabase client initialized`);

// Enhanced logging for Supabase operations
const originalFrom = supabase.from.bind(supabase);
supabase.from = function(table: string) {
  if (!table || table === "") {
    console.error("‚ùå Supabase: Invalid table name provided (empty string)");
    // Fallback to a valid table name to prevent TypeScript errors
    // This will likely fail at runtime but prevents build errors
    return originalFrom("applications");
  }
  console.log(`üîç Supabase: Accessing table "${table}" at ${SUPABASE_URL}/rest/v1/${table}`);
  return originalFrom(table);
} as typeof supabase.from;

// Add a generic RPC function with proper type casting and async handling
export const rpcCall = async <T = any>(
  functionName: string,
  params?: Record<string, any>
): Promise<{ data: T | null; error: any }> => {
  console.log(`üü¢ Calling Supabase RPC function: ${functionName}`, params ? params : 'without params');
  console.log(`üåê RPC Endpoint: ${SUPABASE_URL}/rest/v1/rpc/${functionName}`);
  
  try {
    // Log the full URL for debugging in development
    if (import.meta.env.DEV) {
      console.log(`üåê Supabase RPC URL: ${SUPABASE_URL}/rest/v1/rpc/${functionName}`);
    }
    
    // Use type assertion to allow any string for functionName
    const response = await supabase.rpc(functionName as any, params);
    
    // Log the response
    if (response.error) {
      console.error(`‚ùå Supabase RPC error in ${functionName}:`, response.error);
      
      // Error details for PostgrestError - use optional chaining to safely access properties
      console.error(`‚ùå Message: ${response.error.message}`);
      
      // Only log additional details if they exist
      if (response.error.details) {
        console.error(`‚ùå Error details:`, response.error.details);
      }
      
      if (response.error.hint) {
        console.error(`‚ùå Error hint:`, response.error.hint);
      }
      
      if (response.error.code) {
        console.error(`‚ùå Error code:`, response.error.code);
      }
    } else {
      console.log(`‚úÖ Supabase RPC success for ${functionName}:`, response.data ? 'Data received' : 'No data');
      if (import.meta.env.DEV) {
        console.log(`üì¶ Response data:`, response.data);
      }
    }
    
    // Return in the expected format
    return {
      data: response.data as T | null,
      error: response.error
    };
  } catch (err) {
    console.error(`‚ùå‚ùå Unexpected error in Supabase RPC call to ${functionName}:`, err);
    return {
      data: null,
      error: err
    };
  }
};

// Track all network requests to Supabase for debugging
const monitorSupabaseFetch = () => {
  const originalFetch = window.fetch;
  window.fetch = function(input, init) {
    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input instanceof Request ? input.url : '';
    
    // Only monitor Supabase requests
    if (url.includes(SUPABASE_URL)) {
      const method = init?.method || 'GET';
      console.log(`üåê Supabase Network Request: ${method} ${url}`);
      
      if (init?.body) {
        try {
          const body = JSON.parse(init.body as string);
          console.log(`üì§ Request Payload:`, body);
        } catch (err) {
          console.log(`üì§ Request Payload (raw):`, init.body);
        }
      }
      
      return originalFetch.apply(this, [input, init]).then(
        response => {
          // Clone the response so we can read the body
          const clonedResponse = response.clone();
          
          clonedResponse.json().then(
            data => {
              console.log(`üì• Supabase Response (${response.status}):`, data);
            },
            err => {
              console.log(`üì• Supabase Response (${response.status}): Could not parse JSON`, err);
            }
          );
          
          return response;
        },
        error => {
          console.error(`‚ùå Supabase Network Error:`, error);
          throw error;
        }
      );
    }
    
    return originalFetch.apply(this, [input, init]);
  };
  
  console.log('üîç Supabase network monitoring enabled');
};

// Initialize network monitoring in development mode
if (import.meta.env.DEV) {
  monitorSupabaseFetch();
}

// Enhance supabase insert and update operations with better logging
const enhanceSupabaseInsert = () => {
  const originalInsert = supabase.from('applications').insert;
  
  supabase.from = function(table: string) {
    if (!table || table === "") {
      console.error("‚ùå Supabase: Invalid table name provided (empty string)");
      // Fallback to a valid table name to prevent TypeScript errors
      return originalFrom("applications");
    }
    
    const builder = originalFrom(table);
    const originalInsertFn = builder.insert;
    
    // Enhance the insert function with better logging
    builder.insert = function(...args) {
      console.log(`üìù Supabase: INSERT into "${table}" with data:`, args[0]);
      console.log(`üåê INSERT endpoint: ${SUPABASE_URL}/rest/v1/${table}`);
      
      const insertResult = originalInsertFn.apply(this, args);
      
      // Add a then handler to log the result
      const originalThen = insertResult.then;
      insertResult.then = function(onFulfilled, onRejected) {
        return originalThen.call(this, (result) => {
          if (result.error) {
            console.error(`‚ùå Supabase: INSERT failed for "${table}":`, result.error);
            console.error(`‚ùå Error message: ${result.error.message}`);
            console.error(`‚ùå Error details:`, result.error.details);
            console.error(`‚ùå Error code:`, result.error.code);
          } else {
            console.log(`‚úÖ Supabase: INSERT successful for "${table}"`, result.data);
          }
          return onFulfilled ? onFulfilled(result) : result;
        }, onRejected);
      };
      
      return insertResult;
    };
    
    return builder;
  } as typeof supabase.from;
};

// Initialize the enhanced methods
enhanceSupabaseInsert();

// Add debugging info to Application page to show endpoint and connection status
export const getSupabaseConnectionInfo = () => {
  return {
    url: SUPABASE_URL,
    tables: {
      applications: `${SUPABASE_URL}/rest/v1/applications`
    },
    isConnected: true // This will be updated by the check
  };
};

// Test Supabase connection
export const testSupabaseConnection = async () => {
  try {
    console.log('üîç Testing Supabase connection...');
    const start = Date.now();
    const { data, error } = await supabase.from('applications').select('count(*)').limit(1);
    const elapsed = Date.now() - start;
    
    if (error) {
      console.error(`‚ùå Supabase connection test failed after ${elapsed}ms:`, error);
      return {
        connected: false,
        latency: elapsed,
        error: error.message
      };
    }
    
    console.log(`‚úÖ Supabase connection successful (${elapsed}ms)`);
    return {
      connected: true,
      latency: elapsed,
      data
    };
  } catch (err) {
    // Fix: Define start here since it's not available in this scope
    const start = Date.now();
    const elapsed = Date.now() - start;
    console.error(`‚ùå Unexpected Supabase connection error after ${elapsed}ms:`, err);
    return {
      connected: false,
      latency: elapsed,
      error: err instanceof Error ? err.message : String(err)
    };
  }
};

