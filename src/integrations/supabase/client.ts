// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/lib/types/supabase-types';
import { toast } from 'sonner';

const SUPABASE_URL = "https://kgtfpuvksmqyaraijoal.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtndGZwdXZrc21xeWFyYWlqb2FsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM4MjAxMjksImV4cCI6MjA1OTM5NjEyOX0._fj5EqjZBmS_fHB5Z2p2lDJdXilePMUrbf3If_wGBz0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

console.log(`üîå Initializing Supabase client with URL: ${SUPABASE_URL}`);

// Create client with automatic retry and enhanced error handling
const options = {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true
  },
  global: {
    headers: {
      'x-application-name': 'ontario-loans',
      'x-client-info': 'application-form'
    }
  },
  realtime: {
    params: {
      eventsPerSecond: 1
    }
  }
};

// Create the Supabase client without the problematic db.schema property
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, options);

// Log supabase version info
console.log(`üìä Supabase client initialized`);

// Enhanced logging for Supabase operations
const originalFrom = supabase.from.bind(supabase);
supabase.from = function(table: string) {
  if (!table || table === "") {
    console.error("‚ùå Supabase: Invalid table name provided (empty string)");
    return originalFrom("applications");
  }
  console.log(`üîç Supabase: Accessing table "${table}" at ${SUPABASE_URL}/rest/v1/${table}`);
  return originalFrom(table);
} as typeof supabase.from;

// Add a generic RPC function with proper type casting and async handling
export const rpcCall = async <T = any>(
  functionName: string,
  params?: Record<string, any>
): Promise<{ data: T | null; error: any }> => {
  console.log(`üü¢ Calling Supabase RPC function: ${functionName}`, params ? params : 'without params');
  console.log(`üåê RPC Endpoint: ${SUPABASE_URL}/rest/v1/rpc/${functionName}`);
  
  try {
    if (import.meta.env.DEV) {
      console.log(`üåê Supabase RPC URL: ${SUPABASE_URL}/rest/v1/rpc/${functionName}`);
    }
    
    const response = await supabase.rpc(functionName as any, params);
    
    if (response.error) {
      console.error(`‚ùå Supabase RPC error in ${functionName}:`, response.error);
      
      console.error(`‚ùå Message: ${response.error.message}`);
      
      if (response.error.details) {
        console.error(`‚ùå Error details:`, response.error.details);
      }
      
      if (response.error.hint) {
        console.error(`‚ùå Error hint:`, response.error.hint);
      }
      
      if (response.error.code) {
        console.error(`‚ùå Error code:`, response.error.code);
      }
    } else {
      console.log(`‚úÖ Supabase RPC success for ${functionName}:`, response.data ? 'Data received' : 'No data');
      if (import.meta.env.DEV) {
        console.log(`üì¶ Response data:`, response.data);
      }
    }
    
    return {
      data: response.data as T | null,
      error: response.error
    };
  } catch (err) {
    console.error(`‚ùå‚ùå Unexpected error in Supabase RPC call to ${functionName}:`, err);
    return {
      data: null,
      error: err
    };
  }
};

// Improved test Supabase connection function with better error handling and retries
export const testSupabaseConnection = async (retries = 2): Promise<{connected: boolean, latency?: number, error?: string, data?: any}> => {
  let startTime = 0;
  
  try {
    console.log('üîç Testing Supabase connection...');
    startTime = Date.now();
    
    // UPDATED: Reduce timeout from 5000ms to 3000ms and add proper error handling
    const timeoutPromise = new Promise<{data: null, error: any}>((_, reject) => {
      setTimeout(() => {
        reject({ error: { message: "Connection timeout after 3 seconds" } });
      }, 3000);
    });
    
    // Race between the actual query and the timeout
    const result = await Promise.race([
      supabase.from('applications').select('count').limit(1),
      timeoutPromise
    ]);
    
    const elapsed = Date.now() - startTime;
    
    if ('error' in result && result.error) {
      console.error(`‚ùå Supabase connection test failed after ${elapsed}ms:`, result.error);
      
      if (retries > 0) {
        console.log(`Retrying connection test (${retries} attempts left)...`);
        await new Promise(resolve => setTimeout(resolve, 500)); // Reduced from 1000ms to 500ms
        return testSupabaseConnection(retries - 1);
      }
      
      return {
        connected: false,
        latency: elapsed,
        error: result.error.message || "Unknown error"
      };
    }
    
    console.log(`‚úÖ Supabase connection successful (${elapsed}ms)`);
    return {
      connected: true,
      latency: elapsed,
      data: result.data
    };
  } catch (err: any) {
    const elapsed = Date.now() - startTime || 0;
    console.error(`‚ùå Unexpected Supabase connection error after ${elapsed}ms:`, err);
    
    if (retries > 0) {
      console.log(`Retrying connection test (${retries} attempts left)...`);
      await new Promise(resolve => setTimeout(resolve, 500)); // Reduced from 1000ms to 500ms
      return testSupabaseConnection(retries - 1);
    }
    
    return {
      connected: false,
      latency: elapsed,
      error: err instanceof Error ? err.message : String(err)
    };
  }
};

// Add connection heartbeat at regular intervals to keep connection alive (simplified)
let connectionIsActive = false;

const startConnectionHeartbeat = () => {
  if (connectionIsActive) return;
  
  connectionIsActive = true;
  console.log('üîÑ Starting Supabase connection heartbeat');
  
  // Using fetch instead of supabase client for more reliability
  const heartbeatInterval = setInterval(() => {
    fetch(`${SUPABASE_URL}/rest/v1/applications?count=exact`, {
      method: 'HEAD',
      headers: {
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
      }
    }).catch(err => {
      console.warn('üíî Supabase heartbeat error:', err);
    });
  }, 60000); // Every minute
  
  window.addEventListener('beforeunload', () => {
    clearInterval(heartbeatInterval);
  });
};

// Only start heartbeat in production to avoid excessive requests during development
if (import.meta.env.PROD) {
  // Add a small delay before starting the heartbeat
  setTimeout(() => startConnectionHeartbeat(), 5000);
}

// Add debugging info to Application page to show endpoint and connection status
export const getSupabaseConnectionInfo = () => {
  return {
    url: SUPABASE_URL,
    tables: {
      applications: `${SUPABASE_URL}/rest/v1/applications`
    },
    isConnected: true
  };
};

// Check and report connection status on page load
window.addEventListener('DOMContentLoaded', () => {
  // Initialize connection check on page load with a small delay
  setTimeout(() => {
    testSupabaseConnection()
      .then(status => {
        if (!status.connected) {
          console.warn('‚ö†Ô∏è Initial connection check failed. Some features may not work properly.');
          toast.warning("Database connection issues detected. Some features may not work properly.");
        }
      })
      .catch(err => {
        console.error('‚ö†Ô∏è Error during initial connection check:', err);
      });
  }, 2000); // Increased delay to allow page to load first
});

// Expose function to check for network connectivity issues
export const checkNetworkConnectivity = async (): Promise<boolean> => {
  try {
    // First try to fetch a small resource as a general internet connectivity test
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
    
    const response = await fetch('https://www.google.com/favicon.ico', { 
      mode: 'no-cors',
      cache: 'no-cache',
      method: 'HEAD',
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    return true;
  } catch (err) {
    console.error('Network connectivity check failed:', err);
    return false;
  }
};

// Function to diagnose connection issues
export const diagnoseConnectionIssues = async (): Promise<string> => {
  const hasNetwork = await checkNetworkConnectivity();
  
  if (!hasNetwork) {
    return "No network connectivity detected. Please check your internet connection.";
  }
  
  return "Network connection appears to be working, but database connection failed. This may be a temporary issue.";
};
